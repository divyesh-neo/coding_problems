<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Palindromic Partitioning Problem</title>
    <style>
        /* Word-compatible styles */
        body {
            font-family: Calibri, Arial, sans-serif;
            font-size: 11pt;
            line-height: 1.15;
            margin: 1in;
            color: #000000;
        }
        
        h1 {
            font-size: 18pt;
            font-weight: bold;
            color: #2F5496;
            text-align: center;
            margin-bottom: 12pt;
            border-bottom: 2pt solid #2F5496;
            padding-bottom: 6pt;
        }
        
        h2 {
            font-size: 14pt;
            font-weight: bold;
            color: #2F5496;
            margin-top: 18pt;
            margin-bottom: 6pt;
            border-left: 3pt solid #2F5496;
            padding-left: 6pt;
        }
        
        h3 {
            font-size: 12pt;
            font-weight: bold;
            color: #1F4E79;
            margin-top: 12pt;
            margin-bottom: 6pt;
        }
        
        h4 {
            font-size: 11pt;
            font-weight: bold;
            color: #70AD47;
            margin-top: 6pt;
            margin-bottom: 3pt;
        }
        
        p {
            margin-bottom: 6pt;
            text-align: justify;
        }
        
        .difficulty-badge {
            background-color: #FFC000;
            color: #000000;
            padding: 3pt 6pt;
            border-radius: 3pt;
            font-weight: bold;
            display: inline-block;
            margin-bottom: 6pt;
        }
        
        .tags {
            background-color: #F2F2F2;
            padding: 6pt;
            border-radius: 3pt;
            margin-bottom: 12pt;
        }
        
        .tag {
            background-color: #2F5496;
            color: white;
            padding: 2pt 6pt;
            border-radius: 3pt;
            margin: 1pt;
            font-size: 9pt;
            display: inline-block;
        }
        
        .code-block {
            background-color: #1E1E1E;
            color: #D4D4D4;
            padding: 6pt;
            border-radius: 3pt;
            margin: 6pt 0;
            font-family: 'Courier New', monospace;
            font-size: 9pt;
            border-left: 3pt solid #007ACC;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        
        .inline-code {
            background-color: #F8F9FA;
            color: #E74C3C;
            padding: 1pt 3pt;
            border-radius: 2pt;
            font-family: 'Courier New', monospace;
            font-size: 9pt;
            border: 1pt solid #E9ECEF;
        }
        
        .example-box {
            background-color: #F8F9FA;
            border: 1pt solid #DEE2E6;
            border-radius: 3pt;
            padding: 6pt;
            margin: 6pt 0;
            border-left: 3pt solid #28A745;
        }
        
        .visual-diagram {
            background-color: #FFF5F5;
            border: 1pt solid #FBB6CE;
            border-radius: 3pt;
            padding: 6pt;
            margin: 6pt 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            border-left: 3pt solid #E53E3E;
            font-size: 9pt;
        }
        
        .complexity-box {
            background-color: #E8F5E8;
            border: 1pt solid #9AE6B4;
            border-radius: 3pt;
            padding: 6pt;
            margin: 6pt 0;
            border-left: 3pt solid #38A169;
        }
        
        .algorithm-steps {
            background-color: #F7FAFC;
            border: 1pt solid #E2E8F0;
            border-radius: 3pt;
            padding: 6pt;
            margin: 6pt 0;
            border-left: 3pt solid #805AD5;
        }
        
        .note-box {
            background-color: #FFF8E1;
            border: 1pt solid #FFCC02;
            border-radius: 3pt;
            padding: 6pt;
            margin: 6pt 0;
            border-left: 3pt solid #FF9800;
        }
        
        .application-item {
            background-color: #F8F9FF;
            border: 1pt solid #E6E9FF;
            border-radius: 3pt;
            padding: 6pt;
            margin: 3pt 0;
            border-left: 3pt solid #667EEA;
        }
        
        .summary-box {
            background-color: #E8F4FD;
            border: 1pt solid #90CDF4;
            border-radius: 3pt;
            padding: 12pt;
            margin: 12pt 0;
            border-left: 3pt solid #3182CE;
        }
        
        .tree-diagram {
            font-family: 'Courier New', monospace;
            background-color: #F0F9FF;
            border: 1pt solid #7DD3FC;
            border-radius: 3pt;
            padding: 6pt;
            margin: 6pt 0;
            white-space: pre;
            border-left: 3pt solid #0284C7;
            font-size: 9pt;
        }
        
        .language-label {
            background-color: #667EEA;
            color: white;
            padding: 3pt 6pt;
            border-radius: 3pt 3pt 0 0;
            font-weight: bold;
            display: inline-block;
            font-size: 9pt;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 6pt 0;
            border: 1pt solid #000000;
        }
        
        th, td {
            padding: 6pt;
            text-align: left;
            border: 1pt solid #000000;
            vertical-align: top;
        }
        
        th {
            background-color: #667EEA;
            color: white;
            font-weight: bold;
        }
        
        ol, ul {
            margin: 6pt 0;
            padding-left: 18pt;
        }
        
        li {
            margin-bottom: 3pt;
        }
        
        strong {
            font-weight: bold;
            color: #2C3E50;
        }
        
        em {
            font-style: italic;
            color: #7F8C8D;
        }
    </style>
</head>
<body>
    <h1>Palindromic Partitioning Problem</h1>

    <h2>Difficulty</h2>
    <div class="difficulty-badge">Medium</div>

    <h2>Tags</h2>
    <div class="tags">
        <span class="tag">Dynamic Programming</span>
        <span class="tag">Backtracking</span>
        <span class="tag">String</span>
        <span class="tag">Recursion</span>
        <span class="tag">Matrix Chain Multiplication Pattern</span>
    </div>

    <h2>Problem Statement</h2>
    <p>Given a string <code class="inline-code">s</code>, we need to partition (cut) the string such that every substring of the partition is a palindrome. We need to return all possible palindrome partitionings of the string.</p>

    <p><strong>What is a palindrome?</strong><br>
    A palindrome is a word that reads the same forward and backward. Examples: "aba", "racecar", "noon", "a"</p>

    <p><strong>What is partitioning?</strong><br>
    Partitioning means dividing the string into smaller parts. For example, "aab" can be partitioned as ["a", "a", "b"] or ["aa", "b"].</p>

    <h2>Examples</h2>

    <div class="example-box">
        <h3>Example 1:</h3>
        <div class="code-block">Input: s = "aab"
Output: [["a","a","b"], ["aa","b"]]

Explanation:
- First partition: "a" | "a" | "b" (all are palindromes ✓)
- Second partition: "aa" | "b" (both are palindromes ✓)</div>
    </div>

    <div class="example-box">
        <h3>Example 2:</h3>
        <div class="code-block">Input: s = "a"
Output: [["a"]]

Explanation: Single character is always a palindrome</div>
    </div>

    <div class="example-box">
        <h3>Example 3:</h3>
        <div class="code-block">Input: s = "aaaa"
Output: [["a","a","a","a"], ["a","a","aa"], ["a","aa","a"], 
         ["aa","a","a"], ["aa","aa"], ["a","aaa"], ["aaa","a"], ["aaaa"]]</div>
    </div>

    <h2>Visual Understanding</h2>
    <p>Let's visualize how we partition the string "aab":</p>

    <div class="visual-diagram">Original String: "aab"

Decision Tree:
                    "aab"
                   /  |  \
                  /   |   \
            "a"|"ab" "aa"|"b" "aab"
               ❌       ✓       ❌
           (ab not    (both    (aab not
           palindrome) palindromes) palindrome)
                        |
                    Solution: ["aa","b"]
                    
For "a"|"ab" branch (continuing):
            "a"|"ab"
               |
            "a"|"a"|"b"
               ✓
         Solution: ["a","a","b"]</div>

    <h2>Solution Approaches</h2>

    <h3>Approach 1: Naive Recursive Solution</h3>

    <h4>Intuition</h4>
    <p>Try all possible ways to partition the string. For each partition, check if all substrings are palindromes. If yes, add to result.</p>

    <h4>Approach</h4>
    <div class="algorithm-steps">
        <ol>
            <li>Start from index 0</li>
            <li>Try to make partitions of different lengths (1 character, 2 characters, etc.)</li>
            <li>For each partition, check if it's a palindrome</li>
            <li>If yes, recursively partition the remaining string</li>
            <li>Collect all valid partitions</li>
        </ol>
    </div>

    <h4>Visual Diagram</h4>
    <div class="tree-diagram">For string "aab":

Step 1: Try partition at position 1
        "a" | "ab"
         ✓     ?
        
Step 2: Check "ab" recursively
        "a" | "a" | "b"
         ✓     ✓     ✓
        Result: ["a", "a", "b"]

Step 3: Try partition at position 2
        "aa" | "b"
         ✓      ✓
        Result: ["aa", "b"]</div>

    <h4>Code Implementation</h4>

    <div class="language-label">C++</div>
    <div class="code-block">// C++ Implementation - Naive Approach
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
        vector&lt;vector&lt;string&gt;&gt; result;
        vector&lt;string&gt; currentPartition;
        
        // Start the recursive partitioning
        backtrack(s, 0, currentPartition, result);
        return result;
    }
    
private:
    void backtrack(string&amp; s, int start, vector&lt;string&gt;&amp; currentPartition, 
                   vector&lt;vector&lt;string&gt;&gt;&amp; result) {
        // Base case: if we've processed entire string
        if (start &gt;= s.length()) {
            result.push_back(currentPartition);
            return;
        }
        
        // Try all possible partitions starting from 'start'
        for (int end = start; end &lt; s.length(); end++) {
            // Extract substring from start to end
            string substring = s.substr(start, end - start + 1);
            
            // Check if current substring is palindrome
            if (isPalindrome(substring)) {
                // Add to current partition
                currentPartition.push_back(substring);
                
                // Recursively partition remaining string
                backtrack(s, end + 1, currentPartition, result);
                
                // Backtrack - remove the last added substring
                currentPartition.pop_back();
            }
        }
    }
    
    bool isPalindrome(string&amp; str) {
        int left = 0, right = str.length() - 1;
        
        // Check characters from both ends
        while (left &lt; right) {
            if (str[left] != str[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
};</div>

    <div class="language-label">Java</div>
    <div class="code-block">// Java Implementation - Naive Approach
import java.util.*;

class Solution {
    public List&lt;List&lt;String&gt;&gt; partition(String s) {
        List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();
        List&lt;String&gt; currentPartition = new ArrayList&lt;&gt;();
        
        // Start recursive partitioning
        backtrack(s, 0, currentPartition, result);
        return result;
    }
    
    private void backtrack(String s, int start, List&lt;String&gt; currentPartition, 
                          List&lt;List&lt;String&gt;&gt; result) {
        // Base case: processed entire string
        if (start &gt;= s.length()) {
            result.add(new ArrayList&lt;&gt;(currentPartition));
            return;
        }
        
        // Try all possible partitions from 'start'
        for (int end = start; end &lt; s.length(); end++) {
            // Extract substring
            String substring = s.substring(start, end + 1);
            
            // Check if palindrome
            if (isPalindrome(substring)) {
                // Add to current partition
                currentPartition.add(substring);
                
                // Recursively process remaining
                backtrack(s, end + 1, currentPartition, result);
                
                // Backtrack - remove last added
                currentPartition.remove(currentPartition.size() - 1);
            }
        }
    }
    
    private boolean isPalindrome(String str) {
        int left = 0, right = str.length() - 1;
        
        // Check from both ends
        while (left &lt; right) {
            if (str.charAt(left) != str.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}</div>

    <div class="language-label">Python</div>
    <div class="code-block"># Python Implementation - Naive Approach
class Solution:
    def partition(self, s: str) -&gt; List[List[str]]:
        result = []
        current_partition = []
        
        # Start recursive partitioning
        self.backtrack(s, 0, current_partition, result)
        return result
    
    def backtrack(self, s, start, current_partition, result):
        # Base case: processed entire string
        if start &gt;= len(s):
            result.append(current_partition[:])  # Add copy of current partition
            return
        
        # Try all possible partitions from 'start'
        for end in range(start, len(s)):
            # Extract substring
            substring = s[start:end + 1]
            
            # Check if palindrome
            if self.is_palindrome(substring):
                # Add to current partition
                current_partition.append(substring)
                
                # Recursively process remaining
                self.backtrack(s, end + 1, current_partition, result)
                
                # Backtrack - remove last added
                current_partition.pop()
    
    def is_palindrome(self, string):
        # Check from both ends
        left, right = 0, len(string) - 1
        
        while left &lt; right:
            if string[left] != string[right]:
                return False
            left += 1
            right -= 1
        
        return True</div>

    <div class="complexity-box">
        <h4>Time Complexity: O(n * 2^n)</h4>
        <p>In worst case, we have 2^n possible partitions (at each position, we can either cut or not cut). For each partition, we check if it's palindrome which takes O(n)</p>
        
        <h4>Space Complexity: O(n)</h4>
        <p>Recursion stack can go up to depth n. Current partition array can have at most n elements (all single characters)</p>
    </div>

    <h3>Approach 2: Optimized with DP (Dynamic Programming)</h3>

    <h4>Intuition</h4>
    <p>Instead of checking palindrome for same substring multiple times, we can precompute and store which substrings are palindromes using a 2D DP table.</p>

    <h4>Approach</h4>
    <div class="algorithm-steps">
        <ol>
            <li>Build a DP table where dp[i][j] = true if s[i...j] is palindrome</li>
            <li>Use this table in our backtracking to avoid redundant palindrome checks</li>
        </ol>
    </div>

    <h4>Visual Diagram of DP Table</h4>
    <div class="tree-diagram">For string "aab":

DP Table (is palindrome?):
    0   1   2
  +---+---+---+
0 | T | F | F |  (a, aa, aab)
  +---+---+---+
1 |   | T | F |  (a, ab)
  +---+---+---+
2 |   |   | T |  (b)
  +---+---+---+

T = True (palindrome), F = False (not palindrome)

How to read: dp[0][1] = Is "aa" palindrome? = True
            dp[1][2] = Is "ab" palindrome? = False</div>

    <h4>Code Implementation</h4>

    <div class="language-label">C++</div>
    <div class="code-block">// C++ Implementation - Optimized with DP
class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
        int n = s.length();
        
        // DP table: dp[i][j] = true if s[i...j] is palindrome
        vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false));
        
        // Build DP table
        buildPalindromeDP(s, dp);
        
        // Find all partitions
        vector&lt;vector&lt;string&gt;&gt; result;
        vector&lt;string&gt; currentPartition;
        backtrack(s, 0, currentPartition, result, dp);
        
        return result;
    }
    
private:
    void buildPalindromeDP(string&amp; s, vector&lt;vector&lt;bool&gt;&gt;&amp; dp) {
        int n = s.length();
        
        // Every single character is palindrome
        for (int i = 0; i &lt; n; i++) {
            dp[i][i] = true;
        }
        
        // Check for 2-character palindromes
        for (int i = 0; i &lt; n - 1; i++) {
            if (s[i] == s[i + 1]) {
                dp[i][i + 1] = true;
            }
        }
        
        // Check for palindromes of length 3 and more
        for (int length = 3; length &lt;= n; length++) {
            for (int i = 0; i &lt;= n - length; i++) {
                int j = i + length - 1;
                
                // Check if s[i...j] is palindrome
                // It's palindrome if s[i] == s[j] AND s[i+1...j-1] is palindrome
                if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                }
            }
        }
    }
    
    void backtrack(string&amp; s, int start, vector&lt;string&gt;&amp; currentPartition,
                   vector&lt;vector&lt;string&gt;&gt;&amp; result, vector&lt;vector&lt;bool&gt;&gt;&amp; dp) {
        // Base case: processed entire string
        if (start &gt;= s.length()) {
            result.push_back(currentPartition);
            return;
        }
        
        // Try all partitions
        for (int end = start; end &lt; s.length(); end++) {
            // Use DP table instead of checking palindrome
            if (dp[start][end]) {
                // Extract substring
                string substring = s.substr(start, end - start + 1);
                currentPartition.push_back(substring);
                
                // Recursive call
                backtrack(s, end + 1, currentPartition, result, dp);
                
                // Backtrack
                currentPartition.pop_back();
            }
        }
    }
};</div>

    <div class="complexity-box">
        <h4>Time Complexity: O(n^2 + n * 2^n)</h4>
        <p>Building DP table takes O(n^2). Backtracking still takes O(n * 2^n) in worst case, but palindrome check is now O(1)</p>
        
        <h4>Space Complexity: O(n^2)</h4>
        <p>DP table requires O(n^2) space. Recursion stack and current partition still take O(n)</p>
    </div>

    <h3>Approach 3: Most Optimal - DP + Memoization</h3>

    <h4>Intuition</h4>
    <p>We can further optimize by memoizing the results of subproblems. If we've already computed all palindrome partitions for a substring, we can reuse that result.</p>

    <h4>Approach</h4>
    <p>Instead of recalculating partitions for the same starting position multiple times, we store (memoize) the results and reuse them.</p>

    <h4>Visual Diagram - Memoization in Action</h4>
    <div class="tree-diagram">String: "aab"

Without Memoization (Redundant Calculations):
                    partition(0)
                   /            \
            "a"|partition(1)    "aa"|partition(2)
                    |                    |
            "a"|partition(2)         "b"|partition(3)
                    |                    |
                "b"|partition(3)        return [[]]
                    |
                return [[]]

Notice: partition(2) is calculated TWICE!

With Memoization:
Step 1: partition(0) - Not in memo, calculate
Step 2: partition(1) - Not in memo, calculate  
Step 3: partition(2) - Not in memo, calculate and STORE in memo
        memo[2] = [["b"]]
Step 4: When we need partition(2) again, just return memo[2]!

Memo Table Evolution:
Initial: memo = {}
After partition(3): memo = {3: [[]]}
After partition(2): memo = {3: [[]], 2: [["b"]]}
After partition(1): memo = {3: [[]], 2: [["b"]], 1: [["a","b"], ["ab"]]}
After partition(0): memo = {3: [[]], 2: [["b"]], 1: [["a","b"]], 0: [["a","a","b"], ["aa","b"]]}</div>

    <h4>Memoization Table Example</h4>
    <table>
        <thead>
            <tr>
                <th>Start</th>
                <th>All Partitions from Start</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>3</td>
                <td>[[]] ← Base case: empty</td>
            </tr>
            <tr>
                <td>2</td>
                <td>[["b"]] ← Only "b" possible</td>
            </tr>
            <tr>
                <td>1</td>
                <td>[["a","b"], ["ab"]] ← Two ways from index 1</td>
            </tr>
            <tr>
                <td>0</td>
                <td>[["a","a","b"], ["aa","b"]] ← All partitions from start</td>
            </tr>
        </tbody>
    </table>

    <h4>Code Implementation - Most Optimal</h4>

    <div class="language-label">C++</div>
    <div class="code-block">// C++ Implementation - Most Optimal with Memoization
class Solution {
private:
    // Memoization map: key = start index, value = all partitions from that index
    unordered_map&lt;int, vector&lt;vector&lt;string&gt;&gt;&gt; memo;
    vector&lt;vector&lt;bool&gt;&gt; dp;
    
public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
        int n = s.length();
        dp.resize(n, vector&lt;bool&gt;(n, false));
        
        // Build palindrome DP table
        buildPalindromeDP(s);
        
        // Get all partitions starting from index 0
        return partitionHelper(s, 0);
    }
    
private:
    void buildPalindromeDP(string&amp; s) {
        int n = s.length();
        
        // Single characters
        for (int i = 0; i &lt; n; i++) {
            dp[i][i] = true;
        }
        
        // Two characters
        for (int i = 0; i &lt; n - 1; i++) {
            if (s[i] == s[i + 1]) {
                dp[i][i + 1] = true;
            }
        }
        
        // Three or more characters
        for (int len = 3; len &lt;= n; len++) {
            for (int i = 0; i &lt;= n - len; i++) {
                int j = i + len - 1;
                if (s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                }
            }
        }
    }
    
    vector&lt;vector&lt;string&gt;&gt; partitionHelper(string&amp; s, int start) {
        // Check if already computed
        if (memo.find(start) != memo.end()) {
            return memo[start];
        }
        
        vector&lt;vector&lt;string&gt;&gt; result;
        
        // Base case: reached end of string
        if (start &gt;= s.length()) {
            result.push_back({});
            return result;
        }
        
        // Try all possible first partitions
        for (int end = start; end &lt; s.length(); end++) {
            if (dp[start][end]) {
                // Current substring is palindrome
                string currentPalindrome = s.substr(start, end - start + 1);
                
                // Get all partitions for remaining string
                vector&lt;vector&lt;string&gt;&gt; remainingPartitions = partitionHelper(s, end + 1);
                
                // Combine current with remaining
                for (auto&amp; partition : remainingPartitions) {
                    vector&lt;string&gt; newPartition;
                    newPartition.push_back(currentPalindrome);
                    newPartition.insert(newPartition.end(), partition.begin(), partition.end());
                    result.push_back(newPartition);
                }
            }
        }
        
        // Memoize result
        memo[start] = result;
        return result;
    }
};</div>

    <div class="complexity-box">
        <h4>Time Complexity: O(n^2 + n * 2^n)</h4>
        <p>DP table construction: O(n^2). With memoization, each subproblem is solved only once. Total unique subproblems: n (one for each starting position)</p>
        
        <h4>Space Complexity: O(n^2 + n * 2^n)</h4>
        <p>DP table: O(n^2). Memoization can store up to 2^n partitions in worst case. Recursion stack: O(n)</p>
    </div>

    <h2>Real-World Applications</h2>
    <div class="note-box">
        <p>This problem has several practical applications:</p>
    </div>

    <div class="application-item">
        <h4>1. Natural Language Processing (NLP)</h4>
        <p>Text segmentation in languages without spaces (Chinese, Japanese). Finding meaningful word boundaries in continuous text</p>
    </div>

    <div class="application-item">
        <h4>2. DNA Sequence Analysis</h4>
        <p>Identifying palindromic sequences in DNA (important for gene regulation). Finding restriction enzyme cut sites</p>
    </div>

    <div class="application-item">
        <h4>3. Data Compression</h4>
        <p>Palindromic structures in encryption keys. Pattern analysis in encrypted messages</p>
    </div>

    <div class="application-item">
        <h4>5. Compiler Design</h4>
        <p>Token parsing and lexical analysis. Breaking source code into meaningful tokens</p>
    </div>

    <div class="application-item">
        <h4>6. URL/Path Parsing</h4>
        <p>Breaking URLs into meaningful segments. File path analysis in operating systems</p>
    </div>

    <h2>Summary</h2>
    <div class="summary-box">
        <p>The Palindromic Partitioning problem teaches us:</p>
        <ol>
            <li><strong>Backtracking</strong> - How to explore all possible solutions</li>
            <li><strong>Dynamic Programming</strong> - How to optimize repeated calculations</li>
            <li><strong>Memoization</strong> - How to cache results for better performance</li>
            <li><strong>String Manipulation</strong> - Working with substrings efficiently</li>
        </ol>

        <p>The key insight is that we can break down the problem into smaller subproblems and use DP to avoid redundant palindrome checks. This pattern appears in many string-based problems and is worth mastering for coding interviews and real applications.</p>
    </div>

</body>
</html>